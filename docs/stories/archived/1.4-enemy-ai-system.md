# Story 1.4: Enemy AI System

## Status: Done

## Story

**As a** player,
**I want** enemies to telegraph their attacks and behave predictably,
**so that** I can make strategic decisions about blocking vs attacking.

## Acceptance Criteria

1. Enemies telegraph their next action (Attack X, Defend X) at start of each turn
2. Enemy intents are visible to the player before they end their turn
3. At least 3 test enemy types with different stat distributions
4. Enemies execute their telegraphed intent during Enemy Phase
5. Enemy attack damage is reduced by player's block first, remainder hits HP
6. Enemy defend action adds block to the enemy
7. Enemy block resets at start of their next turn
8. Dead enemies (0 HP) do not act and are visually distinct

## Tasks / Subtasks

- [x] Create enemy type definitions (AC: 3)
  - [x] Define `EnemyDefinition` interface with id, name, maxHp, moves, moveWeights
  - [x] Define `EnemyMove` interface with intent type, damage/block amount, name
  - [x] Define `IntentType` enum: ATTACK, DEFEND, BUFF, DEBUFF, UNKNOWN

- [x] Create test enemy definitions (AC: 3)
  - [x] **Cultist**: 42 HP, balanced attacker
    - Dark Bolt (Attack 6, 40% weight)
    - Defend (Block 8, 30% weight)
    - Shadow Strike (Attack 9, 30% weight)
  - [x] **Skeleton**: 30 HP, aggressive glass cannon
    - Bone Strike (Attack 8, 50% weight)
    - Rattle (Attack 5, 30% weight)
    - Guard (Block 5, 20% weight)
  - [x] **Zombie**: 55 HP, tanky slow attacker
    - Slam (Attack 10, 40% weight)
    - Shamble (Block 12, 40% weight)
    - Bite (Attack 6, 20% weight)

- [x] Implement intent selection system (AC: 1, 2)
  - [x] `selectIntent(enemy)` - weighted random selection from enemy's moves
  - [x] Store selected intent on enemy state
  - [x] Intent selected at: combat start + after each enemy action
  - [x] Return intent object with type, amount, and display name

- [x] Implement enemy action execution (AC: 4, 5, 6)
  - [x] `executeEnemyTurn(enemies)` - execute all living enemy intents
  - [x] Attack intent: deal damage to player (reduced by player block)
  - [x] Defend intent: add block to enemy
  - [x] After executing, select new intent for next turn

- [x] Implement enemy damage to player (AC: 5)
  - [x] `dealDamageToPlayer(amount)` - applies damage considering player block
  - [x] Player block absorbs damage first
  - [x] Remaining damage hits player HP
  - [x] Player block resets AFTER all enemy attacks resolve

- [x] Implement enemy block system (AC: 6, 7)
  - [x] Enemy block stacks when defending
  - [x] Enemy block reduces incoming damage from player attacks
  - [x] `resetEnemyBlocks()` - called at start of enemy turn, before actions

- [x] Implement dead enemy handling (AC: 8)
  - [x] `isEnemyDead(enemy)` - returns true if HP <= 0
  - [x] Dead enemies skipped in executeEnemyTurn
  - [x] Dead enemies cannot be targeted by player
  - [x] Dead enemy state persists for UI (grayed out display)

- [x] Integrate with combat state machine
  - [x] Call `selectIntent` for all enemies at combat initialization
  - [x] Call `executeEnemyTurn` during ENEMY_ACTION phase
  - [x] Emit events: ENEMY_ATTACKED, ENEMY_DEFENDED, ENEMY_DIED
  - [x] Check victory condition after enemy phase

- [x] Write unit tests for enemy AI
  - [x] Test intent selection respects weights
  - [x] Test enemy attack reduces player HP
  - [x] Test player block absorbs enemy damage
  - [x] Test enemy defend increases enemy block
  - [x] Test enemy block resets each turn
  - [x] Test dead enemies don't act
  - [x] Test new intent selected after action

## Dev Notes

### Enemy Definitions (from IDEAS.txt)

Act 1 enemies from the document:
- Common: Skeleton, Cultist, Zombie (and 5 more for full game)
- Elite: Tomb Guardian, High Cultist
- Boss: The Bonelord

For Phase 1, we only need 3 test enemies. Using Cultist (from prototype), Skeleton, and Zombie as variety.

### Enemy Move Structure

```typescript
interface EnemyMove {
  id: string;
  name: string;
  intent: IntentType;
  damage?: number;    // For ATTACK intents
  block?: number;     // For DEFEND intents
  weight: number;     // Selection probability weight
}

interface EnemyDefinition {
  id: string;
  name: string;
  maxHp: number;
  moves: EnemyMove[];
}

// Example: Cultist
const CULTIST: EnemyDefinition = {
  id: 'cultist',
  name: 'Cultist',
  maxHp: 42,
  moves: [
    { id: 'dark_bolt', name: 'Dark Bolt', intent: IntentType.ATTACK, damage: 6, weight: 40 },
    { id: 'defend', name: 'Defend', intent: IntentType.DEFEND, block: 8, weight: 30 },
    { id: 'shadow_strike', name: 'Shadow Strike', intent: IntentType.ATTACK, damage: 9, weight: 30 }
  ]
};
```

### Weighted Random Selection

```typescript
function selectIntent(enemy: EnemyState): EnemyMove {
  const definition = getEnemyDefinition(enemy.id);
  const moves = definition.moves;
  const totalWeight = moves.reduce((sum, m) => sum + m.weight, 0);

  let random = Math.random() * totalWeight;
  for (const move of moves) {
    random -= move.weight;
    if (random <= 0) {
      return move;
    }
  }
  return moves[0]; // Fallback
}
```

### Damage to Player Flow

```typescript
function dealDamageToPlayer(amount: number): { blocked: number; hpDamage: number } {
  const blocked = Math.min(amount, player.block);
  player.block -= blocked;

  const hpDamage = amount - blocked;
  player.hp = Math.max(0, player.hp - hpDamage);

  return { blocked, hpDamage };
}
```

### Enemy Phase Timing (CRITICAL)

Per IDEAS.txt turn structure:
1. Player ends turn
2. **Player block persists** during enemy attacks
3. Enemy attacks resolve (damage reduced by player block)
4. Player block resets to 0
5. New turn starts (Resolve refills, cards drawn)

This means player block gained on Turn 1 protects against Turn 1 enemy attacks.

### Prototype Reference

From `sanctum-deep-mobile.html`:
- `setEnemyIntent(enemy)` - weighted random selection
- `endTurn()` - handles enemy action execution
- Enemy attack logic in the same method

### File Structure

```
src/
  enemies/
    types.ts           - EnemyDefinition, EnemyMove, IntentType
    EnemyDatabase.ts   - All enemy definitions
    EnemyAI.ts         - Intent selection logic
  combat/
    CombatEngine.ts    - Add enemy phase execution
  tests/
    enemies/
      EnemyAI.test.ts
```

### Integration Points

- **Story 1.1**: Enemy phase is part of combat state machine
- **Story 1.2**: Player attacks reduce enemy HP (already implemented)
- **Story 1.5**: UI displays enemy intent icons and block

## Testing

### Test File Location
`src/tests/enemies/EnemyAI.test.ts`

### Key Test Scenarios

1. **Weighted Selection**: Over many iterations, move frequency matches weights
2. **Attack Execution**: Enemy attack 6 vs player block 4 = 4 blocked + 2 HP damage
3. **Defend Execution**: Enemy defend 8 adds 8 to enemy block
4. **Block Reset**: Enemy block 8 resets to 0 next turn
5. **Dead Skip**: Dead enemy (0 HP) doesn't execute intent
6. **Intent Refresh**: After attacking, enemy has new intent for next turn
7. **Multi-Enemy**: All living enemies act in sequence

### Edge Cases

- Player at 0 block takes full damage
- Player block > enemy damage = 0 HP damage
- Enemy dies mid-turn from player attack (can't act next enemy phase)
- All enemies dead = victory (checked after player action, not during enemy phase)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-03 | 1.0 | Initial story creation | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used
claude-opus-4-5-20251101

### Debug Log References
N/A

### Completion Notes List
- Enemy types defined in `src/types/index.ts`
- Enemy definitions in `src/data/enemies/act1.ts`
- Intent selection (weighted random) in CombatEngine.setEnemyIntent()
- Enemy actions executed in CombatEngine.endTurn()
- CombatEngine now stores EnemyDefinitions and uses them for intent selection
- Unit tests in `src/engine/CombatEngine.test.ts` covering all enemy AI scenarios
- All acceptance criteria verified with passing tests

### File List
- src/types/index.ts (EnemyDefinition, EnemyMove, IntentType)
- src/data/enemies/act1.ts (created)
- src/engine/CombatEngine.ts (modified)
- src/engine/CombatEngine.test.ts (Enemy AI tests)

---

## QA Results
_To be filled by QA agent_
