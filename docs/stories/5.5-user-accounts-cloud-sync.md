# Story 5.5: User Accounts & Cloud Sync

## Status: Approved

## Story

**As a** player,
**I want** to create an account and sync my progress to the cloud,
**so that** I can play on multiple devices and never lose my purchases.

## Acceptance Criteria

1. Players can create accounts (email, Google, Discord OAuth)
2. Account links to all purchases (premium classes)
3. Progress syncs to cloud automatically when logged in
4. Conflict resolution when local and cloud differ
5. Guest mode works without account (local only)
6. Account deletion removes all cloud data (GDPR)
7. Secure authentication with JWT tokens

## Tasks / Subtasks

- [ ] Design authentication flow (AC: 1, 7)
  - [ ] Email/password signup and login
  - [ ] Google OAuth integration
  - [ ] Discord OAuth integration
  - [ ] Password reset flow
  - [ ] Email verification
  - [ ] JWT token management

- [ ] Design backend API endpoints
  - [ ] POST /auth/register (email/password)
  - [ ] POST /auth/login (email/password)
  - [ ] POST /auth/oauth/google
  - [ ] POST /auth/oauth/discord
  - [ ] POST /auth/logout
  - [ ] POST /auth/refresh (refresh token)
  - [ ] POST /auth/password-reset
  - [ ] GET /user/profile
  - [ ] DELETE /user (account deletion)
  - [ ] GET /sync/pull (get cloud save)
  - [ ] POST /sync/push (upload local save)
  - [ ] GET /purchases (owned DLC)
  - [ ] POST /purchases/verify (verify receipt)

- [ ] Implement client-side AuthService
  - [ ] Create `src/services/AuthService.ts`
  - [ ] Token storage (secure)
  - [ ] Auto-refresh tokens
  - [ ] Login/logout state management
  - [ ] OAuth popup handling

- [ ] Implement cloud sync service
  - [ ] Create `src/services/CloudSyncService.ts`
  - [ ] Sync on login
  - [ ] Sync on save (debounced)
  - [ ] Sync on app focus (returning to tab)
  - [ ] Offline queue for failed syncs
  - [ ] Conflict detection

- [ ] Implement conflict resolution (AC: 4)
  - [ ] Compare timestamps
  - [ ] Compare progress (more achievements = newer)
  - [ ] User choice dialog for conflicts
  - [ ] Merge when possible (achievements union)
  - [ ] Never lose purchases

- [ ] Implement purchase linking (AC: 2)
  - [ ] Store purchases on backend
  - [ ] Verify purchases on login
  - [ ] Restore purchases on new device
  - [ ] Handle purchase receipts (Stripe)

- [ ] Implement guest mode (AC: 5)
  - [ ] Full functionality without account
  - [ ] "Login to sync" prompts (non-intrusive)
  - [ ] Convert guest to account (keep progress)

- [ ] Implement account management UI
  - [ ] Login/signup screen
  - [ ] Profile screen
  - [ ] Link additional OAuth providers
  - [ ] Change password
  - [ ] Delete account (with confirmation)
  - [ ] Sync status indicator
  - [ ] Last synced timestamp

- [ ] Implement account deletion (AC: 6)
  - [ ] Multi-step confirmation
  - [ ] 30-day grace period option
  - [ ] Delete all cloud data
  - [ ] Revoke all tokens
  - [ ] GDPR compliance

- [ ] Write unit tests
  - [ ] Test auth flow
  - [ ] Test token refresh
  - [ ] Test sync push/pull
  - [ ] Test conflict resolution
  - [ ] Test offline queue

## Dev Notes

### Authentication Architecture

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   Game Client   │────▶│   Auth Server   │────▶│    Database     │
│                 │◀────│   (API)         │◀────│   (PostgreSQL)  │
└─────────────────┘     └─────────────────┘     └─────────────────┘
         │                      │
         │                      ▼
         │              ┌─────────────────┐
         │              │  OAuth Providers │
         │              │  (Google/Discord)│
         │              └─────────────────┘
         │
         ▼
  ┌─────────────────┐
  │  localStorage   │
  │  (JWT tokens)   │
  └─────────────────┘
```

### Auth Service Implementation

```typescript
// src/services/AuthService.ts
export interface User {
  id: string;
  email: string;
  displayName: string;
  avatarUrl?: string;
  providers: ('email' | 'google' | 'discord')[];
  createdAt: string;
}

export interface AuthState {
  isAuthenticated: boolean;
  user: User | null;
  isLoading: boolean;
}

export class AuthService {
  private accessToken: string | null = null;
  private refreshToken: string | null = null;
  private user: User | null = null;
  private listeners: ((state: AuthState) => void)[] = [];

  constructor() {
    this.loadStoredTokens();
    this.scheduleTokenRefresh();
  }

  async login(email: string, password: string): Promise<void> {
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new AuthError(error.message, error.code);
    }

    const { accessToken, refreshToken, user } = await response.json();
    this.setTokens(accessToken, refreshToken);
    this.user = user;
    this.notifyListeners();

    // Trigger sync after login
    await cloudSyncService.syncOnLogin();
  }

  async loginWithGoogle(): Promise<void> {
    // Open OAuth popup
    const popup = window.open(
      '/api/auth/oauth/google',
      'Google Login',
      'width=500,height=600'
    );

    // Listen for callback
    return new Promise((resolve, reject) => {
      const handleMessage = (event: MessageEvent) => {
        if (event.origin !== window.location.origin) return;
        if (event.data.type === 'oauth_success') {
          this.setTokens(event.data.accessToken, event.data.refreshToken);
          this.user = event.data.user;
          this.notifyListeners();
          cloudSyncService.syncOnLogin();
          resolve();
        } else if (event.data.type === 'oauth_error') {
          reject(new AuthError(event.data.message, 'OAUTH_FAILED'));
        }
        window.removeEventListener('message', handleMessage);
      };
      window.addEventListener('message', handleMessage);
    });
  }

  async logout(): Promise<void> {
    await fetch('/api/auth/logout', {
      method: 'POST',
      headers: this.getAuthHeaders(),
    });

    this.clearTokens();
    this.user = null;
    this.notifyListeners();
  }

  async register(email: string, password: string, displayName: string): Promise<void> {
    const response = await fetch('/api/auth/register', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password, displayName }),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new AuthError(error.message, error.code);
    }

    // Auto-login after registration
    await this.login(email, password);
  }

  async deleteAccount(): Promise<void> {
    const response = await fetch('/api/user', {
      method: 'DELETE',
      headers: this.getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error('Failed to delete account');
    }

    this.clearTokens();
    this.user = null;
    // Clear local data too
    localStorage.clear();
    this.notifyListeners();
  }

  private async refreshAccessToken(): Promise<void> {
    if (!this.refreshToken) return;

    const response = await fetch('/api/auth/refresh', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ refreshToken: this.refreshToken }),
    });

    if (response.ok) {
      const { accessToken, refreshToken } = await response.json();
      this.setTokens(accessToken, refreshToken);
    } else {
      // Refresh failed, log out
      this.clearTokens();
      this.user = null;
      this.notifyListeners();
    }
  }

  private setTokens(access: string, refresh: string): void {
    this.accessToken = access;
    this.refreshToken = refresh;
    localStorage.setItem('accessToken', access);
    localStorage.setItem('refreshToken', refresh);
    this.scheduleTokenRefresh();
  }

  private clearTokens(): void {
    this.accessToken = null;
    this.refreshToken = null;
    localStorage.removeItem('accessToken');
    localStorage.removeItem('refreshToken');
  }

  getAuthHeaders(): Record<string, string> {
    return this.accessToken
      ? { Authorization: `Bearer ${this.accessToken}` }
      : {};
  }

  isAuthenticated(): boolean {
    return !!this.accessToken && !!this.user;
  }

  getUser(): User | null {
    return this.user;
  }

  onAuthStateChange(callback: (state: AuthState) => void): () => void {
    this.listeners.push(callback);
    return () => {
      this.listeners = this.listeners.filter(l => l !== callback);
    };
  }
}
```

### Cloud Sync Service

```typescript
// src/services/CloudSyncService.ts
export interface SyncResult {
  status: 'success' | 'conflict' | 'error';
  message?: string;
  cloudData?: SaveData;
  localData?: SaveData;
}

export class CloudSyncService {
  private syncQueue: SaveData[] = [];
  private isSyncing: boolean = false;
  private lastSyncTime: number = 0;

  async syncOnLogin(): Promise<SyncResult> {
    const cloudData = await this.pullFromCloud();
    const localData = saveManager.getSaveData();

    if (!cloudData) {
      // No cloud data, push local
      await this.pushToCloud(localData);
      return { status: 'success' };
    }

    if (!localData.meta.soulEchoes && localData.meta.unlockedAchievements.length === 0) {
      // Local is fresh, use cloud
      saveManager.loadSaveData(cloudData);
      return { status: 'success' };
    }

    // Both have data, check for conflicts
    const conflict = this.detectConflict(localData, cloudData);
    if (conflict) {
      return {
        status: 'conflict',
        cloudData,
        localData,
      };
    }

    // No conflict, merge and push
    const merged = this.mergeSaveData(localData, cloudData);
    saveManager.loadSaveData(merged);
    await this.pushToCloud(merged);
    return { status: 'success' };
  }

  async pushToCloud(data: SaveData): Promise<void> {
    if (!authService.isAuthenticated()) return;

    try {
      const response = await fetch('/api/sync/push', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...authService.getAuthHeaders(),
        },
        body: JSON.stringify({
          data: LZString.compressToBase64(JSON.stringify(data)),
          timestamp: Date.now(),
        }),
      });

      if (!response.ok) {
        throw new Error('Sync push failed');
      }

      this.lastSyncTime = Date.now();
    } catch (e) {
      // Queue for retry
      this.syncQueue.push(data);
      this.scheduleRetry();
    }
  }

  async pullFromCloud(): Promise<SaveData | null> {
    if (!authService.isAuthenticated()) return null;

    const response = await fetch('/api/sync/pull', {
      headers: authService.getAuthHeaders(),
    });

    if (!response.ok) {
      if (response.status === 404) return null;
      throw new Error('Sync pull failed');
    }

    const { data } = await response.json();
    return JSON.parse(LZString.decompressFromBase64(data));
  }

  private detectConflict(local: SaveData, cloud: SaveData): boolean {
    // Conflict if both modified since last sync and different
    const localModified = local.lastSaved > this.lastSyncTime;
    const cloudModified = cloud.lastSaved > this.lastSyncTime;

    if (!localModified || !cloudModified) return false;

    // Check if meaningfully different
    const localProgress = this.calculateProgress(local);
    const cloudProgress = this.calculateProgress(cloud);

    // If one is clearly ahead, no conflict
    if (Math.abs(localProgress - cloudProgress) > 100) return false;

    // Similar progress, timestamps differ = conflict
    return local.lastSaved !== cloud.lastSaved;
  }

  private calculateProgress(data: SaveData): number {
    return (
      data.meta.soulEchoes +
      data.meta.unlockedAchievements.length * 10 +
      data.meta.purchasedUpgrades.length * 5
    );
  }

  private mergeSaveData(local: SaveData, cloud: SaveData): SaveData {
    // Merge strategy: union of achievements/upgrades, max of currencies
    return {
      version: Math.max(local.version, cloud.version),
      checksum: '',
      lastSaved: Date.now(),
      meta: {
        soulEchoes: Math.max(local.meta.soulEchoes, cloud.meta.soulEchoes),
        totalSoulEchoesEarned: Math.max(
          local.meta.totalSoulEchoesEarned,
          cloud.meta.totalSoulEchoesEarned
        ),
        unlockedAchievements: [
          ...new Set([
            ...local.meta.unlockedAchievements,
            ...cloud.meta.unlockedAchievements,
          ]),
        ],
        achievementProgress: this.mergeProgress(
          local.meta.achievementProgress,
          cloud.meta.achievementProgress
        ),
        purchasedUpgrades: [
          ...new Set([
            ...local.meta.purchasedUpgrades,
            ...cloud.meta.purchasedUpgrades,
          ]),
        ],
        purchasedClasses: [
          ...new Set([
            ...local.meta.purchasedClasses,
            ...cloud.meta.purchasedClasses,
          ]),
        ],
        statistics: this.mergeStatistics(local.meta.statistics, cloud.meta.statistics),
      },
      run: local.run || cloud.run, // Prefer local active run
      settings: local.settings, // Always use local settings
    };
  }

  private mergeProgress(
    a: Record<string, number>,
    b: Record<string, number>
  ): Record<string, number> {
    const result = { ...a };
    for (const [key, value] of Object.entries(b)) {
      result[key] = Math.max(result[key] || 0, value);
    }
    return result;
  }

  private mergeStatistics(a: PlayerStatistics, b: PlayerStatistics): PlayerStatistics {
    return {
      totalRuns: Math.max(a.totalRuns, b.totalRuns),
      totalWins: Math.max(a.totalWins, b.totalWins),
      totalDeaths: Math.max(a.totalDeaths, b.totalDeaths),
      totalPlayTime: Math.max(a.totalPlayTime, b.totalPlayTime),
      enemiesDefeated: Math.max(a.enemiesDefeated, b.enemiesDefeated),
      bossesDefeated: Math.max(a.bossesDefeated, b.bossesDefeated),
      cardsPlayed: Math.max(a.cardsPlayed, b.cardsPlayed),
      damageDealt: Math.max(a.damageDealt, b.damageDealt),
      damageBlocked: Math.max(a.damageBlocked, b.damageBlocked),
      healingDone: Math.max(a.healingDone, b.healingDone),
      goldEarned: Math.max(a.goldEarned, b.goldEarned),
      runsPerClass: this.mergeClassStats(a.runsPerClass, b.runsPerClass),
      fastestWin: Math.min(a.fastestWin || Infinity, b.fastestWin || Infinity) || null,
    };
  }
}
```

### Conflict Resolution UI

```typescript
// src/ui/screens/SyncConflictScreen.ts
export function showSyncConflict(
  localData: SaveData,
  cloudData: SaveData
): Promise<'local' | 'cloud' | 'merge'> {
  return new Promise((resolve) => {
    const dialog = createDialog({
      title: 'Sync Conflict',
      content: `
        <p>Your local save and cloud save have both changed since your last sync.</p>

        <div class="conflict-comparison">
          <div class="conflict-option local">
            <h4>Local Save</h4>
            <p>Soul Echoes: ${localData.meta.soulEchoes}</p>
            <p>Achievements: ${localData.meta.unlockedAchievements.length}</p>
            <p>Last saved: ${formatDate(localData.lastSaved)}</p>
          </div>

          <div class="conflict-option cloud">
            <h4>Cloud Save</h4>
            <p>Soul Echoes: ${cloudData.meta.soulEchoes}</p>
            <p>Achievements: ${cloudData.meta.unlockedAchievements.length}</p>
            <p>Last saved: ${formatDate(cloudData.lastSaved)}</p>
          </div>
        </div>
      `,
      buttons: [
        {
          label: 'Keep Local',
          onClick: () => resolve('local'),
        },
        {
          label: 'Keep Cloud',
          onClick: () => resolve('cloud'),
        },
        {
          label: 'Merge (Recommended)',
          style: 'primary',
          onClick: () => resolve('merge'),
        },
      ],
    });
    dialog.show();
  });
}
```

### Login/Signup UI

```html
<div id="auth-screen" class="screen">
  <header class="screen-header">
    <button class="back-btn">← Back</button>
    <h2>Account</h2>
  </header>

  <div class="auth-tabs">
    <button class="tab active" data-tab="login">Login</button>
    <button class="tab" data-tab="signup">Sign Up</button>
  </div>

  <div class="auth-form" id="login-form">
    <input type="email" placeholder="Email" id="login-email" />
    <input type="password" placeholder="Password" id="login-password" />
    <button class="btn primary" id="login-btn">Login</button>
    <a href="#" id="forgot-password">Forgot password?</a>
  </div>

  <div class="auth-form hidden" id="signup-form">
    <input type="text" placeholder="Display Name" id="signup-name" />
    <input type="email" placeholder="Email" id="signup-email" />
    <input type="password" placeholder="Password" id="signup-password" />
    <input type="password" placeholder="Confirm Password" id="signup-confirm" />
    <button class="btn primary" id="signup-btn">Create Account</button>
  </div>

  <div class="oauth-divider">
    <span>or continue with</span>
  </div>

  <div class="oauth-buttons">
    <button class="oauth-btn google" id="google-login">
      <img src="/icons/google.svg" alt="Google" />
      Google
    </button>
    <button class="oauth-btn discord" id="discord-login">
      <img src="/icons/discord.svg" alt="Discord" />
      Discord
    </button>
  </div>

  <p class="guest-note">
    <a href="#" id="continue-guest">Continue as Guest</a>
    <br />
    <small>Progress won't sync across devices</small>
  </p>
</div>
```

### Backend API Schema (Reference)

```typescript
// Backend types for API endpoints
interface RegisterRequest {
  email: string;
  password: string;
  displayName: string;
}

interface LoginRequest {
  email: string;
  password: string;
}

interface AuthResponse {
  accessToken: string;
  refreshToken: string;
  user: User;
}

interface SyncPushRequest {
  data: string; // Compressed save data
  timestamp: number;
}

interface SyncPullResponse {
  data: string;
  timestamp: number;
}

// Database schema (PostgreSQL)
/*
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE,
  password_hash VARCHAR(255),
  display_name VARCHAR(100) NOT NULL,
  avatar_url TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE oauth_connections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id),
  provider VARCHAR(50) NOT NULL,
  provider_user_id VARCHAR(255) NOT NULL,
  UNIQUE(provider, provider_user_id)
);

CREATE TABLE save_data (
  user_id UUID PRIMARY KEY REFERENCES users(id),
  data TEXT NOT NULL,
  timestamp BIGINT NOT NULL,
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE purchases (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id),
  product_id VARCHAR(100) NOT NULL,
  stripe_receipt_id VARCHAR(255),
  purchased_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(user_id, product_id)
);
*/
```

### Security Considerations

1. **Password Hashing**: bcrypt with salt rounds >= 12
2. **JWT Tokens**: Short-lived access (15min), long refresh (7 days)
3. **HTTPS Only**: All API calls over TLS
4. **Rate Limiting**: Login attempts limited to 5/minute
5. **CORS**: Strict origin checking
6. **XSS Prevention**: Sanitize all user input
7. **CSRF Protection**: Token verification on state-changing requests

## Testing

### Test File Location
`src/tests/services/AuthService.test.ts`
`src/tests/services/CloudSyncService.test.ts`

### Key Test Scenarios

1. **Registration**: Creates account, returns tokens
2. **Login**: Validates credentials, returns tokens
3. **OAuth**: Handles popup flow, links account
4. **Token Refresh**: Refreshes before expiry
5. **Sync Push**: Uploads save data
6. **Sync Pull**: Downloads save data
7. **Conflict Detection**: Identifies concurrent edits
8. **Merge**: Combines saves correctly
9. **Account Deletion**: Removes all user data
10. **Guest Mode**: Works without auth

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-03 | 1.0 | Initial story creation | James (Dev) |

---

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

---

## QA Results
_To be filled by QA agent_
