# Story 2.1: Map Data Model & Generation

## Status: Not Started

## Story

**As a** player starting a new run,
**I want** a procedurally generated map with branching paths,
**So that** each run feels unique and I can make strategic path choices.

## Acceptance Criteria

1. Map generates 15 nodes per act (45 total across 3 acts)
2. Map uses seeded RNG for deterministic generation (shareable runs)
3. Each row has 2-4 nodes with connections to 1-3 nodes in the next row
4. First row always starts with a single entry node
5. Last row in each act is always a boss node
6. Node types are distributed according to rules:
   - Combat: 50-60% of non-boss nodes
   - Elite: 2-3 per act, never in first 3 rows
   - Campfire: 2-3 per act, never adjacent to boss
   - Merchant: 1-2 per act
   - Shrine: 1-2 per act
7. Map data structure includes: nodeId, type, row, connections, visited flag

## Tasks / Subtasks

- [ ] Define map data types (AC: 7)
  - [ ] Create MapNode interface with id, type, row, connections, visited
  - [ ] Create FloorMap interface with act, rows, bossNode
  - [ ] Create NodeType enum: COMBAT, ELITE, CAMPFIRE, MERCHANT, SHRINE, BOSS
  - [ ] Export types from src/types/index.ts

- [ ] Implement SeededRandom utility (AC: 2)
  - [ ] Create SeededRandom class using mulberry32 algorithm
  - [ ] Implement next(): number (0-1 range)
  - [ ] Implement nextInt(min, max): number
  - [ ] Implement shuffle<T>(array: T[]): T[]
  - [ ] Implement weightedChoice<T>(items, weights): T
  - [ ] Write unit tests for determinism

- [ ] Create MapGenerator class (AC: 1, 3, 4, 5)
  - [ ] Implement generateFloor(act: number, seed: string): FloorMap
  - [ ] Generate 15 rows per act
  - [ ] First row has single entry node
  - [ ] Last row has single boss node
  - [ ] Each row has 2-4 nodes (randomized)
  - [ ] Generate connections between rows (each node connects to 1-3 in next row)

- [ ] Implement node type distribution (AC: 6)
  - [ ] Calculate node type quotas per act
  - [ ] Assign types respecting placement rules
  - [ ] Elite: rows 4+ only
  - [ ] Campfire: not row 14 (adjacent to boss)
  - [ ] Fill remaining with Combat nodes

- [ ] Validate map connectivity (AC: 7)
  - [ ] Ensure all nodes reachable from start
  - [ ] Ensure all nodes can reach boss
  - [ ] No orphan nodes
  - [ ] Implement validateMap(floor: FloorMap): boolean

- [ ] Write unit tests
  - [ ] Test deterministic generation (same seed = same map)
  - [ ] Test node count per act
  - [ ] Test connection validity
  - [ ] Test node type distribution
  - [ ] Test elite placement rules
  - [ ] Test campfire placement rules
  - [ ] Test no orphan nodes

## Dev Notes

### Seeded Random Implementation

Use mulberry32 algorithm for fast, deterministic RNG:

```typescript
class SeededRandom {
  private state: number;

  constructor(seed: string) {
    // Convert string seed to number
    this.state = this.hashString(seed);
  }

  private hashString(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash) || 1;
  }

  next(): number {
    // mulberry32
    let t = this.state += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }

  nextInt(min: number, max: number): number {
    return Math.floor(this.next() * (max - min + 1)) + min;
  }

  shuffle<T>(array: T[]): T[] {
    const result = [...array];
    for (let i = result.length - 1; i > 0; i--) {
      const j = this.nextInt(0, i);
      [result[i], result[j]] = [result[j], result[i]];
    }
    return result;
  }
}
```

### Map Generation Algorithm

```typescript
function generateFloor(act: number, seed: string): FloorMap {
  const rng = new SeededRandom(`${seed}_act${act}`);
  const rows: MapNode[][] = [];

  // Row 0: Single entry node (Combat)
  rows.push([createNode('COMBAT', 0, 0, act)]);

  // Rows 1-13: 2-4 nodes each
  for (let row = 1; row < 14; row++) {
    const nodeCount = rng.nextInt(2, 4);
    const rowNodes: MapNode[] = [];
    for (let n = 0; n < nodeCount; n++) {
      rowNodes.push(createNode('COMBAT', row, n, act)); // Type assigned later
    }
    rows.push(rowNodes);
  }

  // Row 14: Boss node
  rows.push([createNode('BOSS', 14, 0, act)]);

  // Generate connections
  for (let row = 0; row < rows.length - 1; row++) {
    generateConnections(rows[row], rows[row + 1], rng);
  }

  // Assign node types
  assignNodeTypes(rows, act, rng);

  return { act, rows, bossNode: rows[14][0] };
}
```

### Connection Generation

Each node in row N connects to 1-3 nodes in row N+1.
Ensure no orphans:
1. First, ensure each node in N+1 has at least one incoming connection
2. Then, add additional random connections

```typescript
function generateConnections(fromRow: MapNode[], toRow: MapNode[], rng: SeededRandom): void {
  // First pass: ensure every toRow node has at least one connection
  for (const toNode of toRow) {
    const fromNode = fromRow[rng.nextInt(0, fromRow.length - 1)];
    if (!fromNode.connections.includes(toNode.id)) {
      fromNode.connections.push(toNode.id);
    }
  }

  // Second pass: add additional connections (1-2 more per node)
  for (const fromNode of fromRow) {
    const additionalConnections = rng.nextInt(0, 2);
    for (let i = 0; i < additionalConnections; i++) {
      const toNode = toRow[rng.nextInt(0, toRow.length - 1)];
      if (!fromNode.connections.includes(toNode.id)) {
        fromNode.connections.push(toNode.id);
      }
    }
  }
}
```

### File Structure

```
src/
  map/
    types.ts           - MapNode, FloorMap, NodeType
    SeededRandom.ts    - Deterministic RNG
    MapGenerator.ts    - Floor generation
  tests/
    map/
      SeededRandom.test.ts
      MapGenerator.test.ts
```

## Testing

### Test File Location
`src/tests/map/MapGenerator.test.ts`

### Key Test Scenarios

1. **Determinism**: Same seed produces identical maps
2. **Node Count**: Each act has exactly 15 rows
3. **Entry Node**: Row 0 has single combat node
4. **Boss Node**: Row 14 has single boss node
5. **Connections**: All nodes have valid connections
6. **Reachability**: All nodes reachable from start
7. **Elite Placement**: No elites in rows 0-3
8. **Campfire Placement**: No campfires in row 13
9. **Type Distribution**: Correct count of each type

### Edge Cases

- Very short seeds (1 char)
- Very long seeds (100+ chars)
- Empty seed (should use default)
- Special characters in seed

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-03 | 1.0 | Initial story creation | John (PM) |

---

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

---

## QA Results
_To be filled by QA agent_
