# Story 5.4: Save/Load System

## Status: Draft

## Story

**As a** player,
**I want** my game progress to save automatically,
**so that** I can resume runs later and never lose my achievements or upgrades.

## Acceptance Criteria

1. Run progress saves automatically at key points
2. Meta-progress (achievements, upgrades, SE) saves immediately on change
3. Player can have one active run save at a time
4. Save data stored in localStorage (with cloud sync in 5.5)
5. Save data is validated on load to prevent corruption
6. Player can manually abandon a run
7. Save versioning for future migrations

## Tasks / Subtasks

- [ ] Design save data schema (AC: 1, 5, 7)
  - [ ] Define RunSaveData structure
  - [ ] Define MetaSaveData structure
  - [ ] Define SettingsSaveData structure
  - [ ] Add version field for migrations
  - [ ] Add checksum for validation

- [ ] Implement save triggers (AC: 1)
  - [ ] Save after each combat ends
  - [ ] Save after card selection
  - [ ] Save after campfire choice
  - [ ] Save after merchant transaction
  - [ ] Save after shrine event
  - [ ] Save after map node selection
  - [ ] Save on Act transition

- [ ] Implement SaveManager service
  - [ ] Create `src/services/SaveManager.ts`
  - [ ] LocalStorage read/write
  - [ ] Data serialization/deserialization
  - [ ] Compression for large saves
  - [ ] Validation on load
  - [ ] Migration system for version updates

- [ ] Implement meta-progress persistence (AC: 2)
  - [ ] Soul Echoes save on change
  - [ ] Achievements save on unlock
  - [ ] Upgrades save on purchase
  - [ ] Settings save on change
  - [ ] Statistics save after runs

- [ ] Implement run save/load
  - [ ] Full run state serialization
  - [ ] Map state with visited nodes
  - [ ] Deck state (all piles)
  - [ ] Player state (HP, gold, relics, potions)
  - [ ] Combat state (if mid-combat)
  - [ ] Resume at correct game state

- [ ] Implement save validation (AC: 5)
  - [ ] Schema validation
  - [ ] Checksum verification
  - [ ] Handle corrupt saves gracefully
  - [ ] Backup system (keep last valid save)

- [ ] Implement run abandonment (AC: 6)
  - [ ] Abandon button in pause menu
  - [ ] Confirmation dialog
  - [ ] Clear run save data
  - [ ] Record run statistics (even for abandons)

- [ ] Implement save versioning (AC: 7)
  - [ ] Version number in save data
  - [ ] Migration functions for each version
  - [ ] Backwards compatibility handling
  - [ ] Clear message if save too old

- [ ] Implement save UI
  - [ ] "Continue" button enabled state
  - [ ] Save indicator (autosaving...)
  - [ ] Last saved timestamp
  - [ ] Abandon run confirmation

- [ ] Write unit tests
  - [ ] Test save/load round trip
  - [ ] Test validation catches corruption
  - [ ] Test migration between versions
  - [ ] Test all save triggers fire correctly

## Dev Notes

### Save Data Schema

```typescript
// src/types/save.ts
export const SAVE_VERSION = 1;

export interface SaveData {
  version: number;
  checksum: string;
  lastSaved: number; // timestamp
  meta: MetaSaveData;
  run: RunSaveData | null;
  settings: SettingsSaveData;
}

export interface MetaSaveData {
  soulEchoes: number;
  totalSoulEchoesEarned: number;
  unlockedAchievements: string[];
  achievementProgress: Record<string, number>;
  purchasedUpgrades: string[];
  purchasedClasses: CharacterClassId[];
  statistics: PlayerStatistics;
}

export interface PlayerStatistics {
  totalRuns: number;
  totalWins: number;
  totalDeaths: number;
  totalPlayTime: number; // seconds
  enemiesDefeated: number;
  bossesDefeated: number;
  cardsPlayed: number;
  damageDealt: number;
  damageBlocked: number;
  healingDone: number;
  goldEarned: number;
  runsPerClass: Record<CharacterClassId, { runs: number; wins: number }>;
  fastestWin: number | null; // seconds
}

export interface RunSaveData {
  seed: string;
  classId: CharacterClassId;
  currentAct: number;
  currentNode: string;
  visitedNodes: string[];
  map: MapSaveData;
  player: PlayerSaveData;
  combat: CombatSaveData | null; // null if not in combat
  runStatistics: RunStatistics;
  startTime: number;
}

export interface PlayerSaveData {
  maxHp: number;
  currentHp: number;
  gold: number;
  deck: CardSaveData[];
  relics: string[]; // relic IDs
  potions: (string | null)[]; // potion IDs, null for empty slots
  // Class-specific
  devotion?: number;
  fortify?: number;
  // etc
}

export interface CardSaveData {
  definitionId: string;
  instanceId: string;
  upgraded: boolean;
  corrupted?: boolean;
}

export interface CombatSaveData {
  turn: number;
  phase: CombatPhase;
  enemies: EnemySaveData[];
  hand: string[]; // instanceIds
  drawPile: string[];
  discardPile: string[];
  exhaustPile: string[];
  playerBlock: number;
  playerResolve: number;
  playerStatusEffects: StatusEffect[];
}

export interface SettingsSaveData {
  masterVolume: number;
  musicVolume: number;
  sfxVolume: number;
  animationSpeed: number;
  screenShake: boolean;
  colorblindMode: boolean;
  fullscreen: boolean;
}
```

### SaveManager Implementation

```typescript
// src/services/SaveManager.ts
import LZString from 'lz-string';

const STORAGE_KEY = 'sanctum_ruins_save';
const BACKUP_KEY = 'sanctum_ruins_save_backup';

export class SaveManager {
  private saveData: SaveData;
  private isDirty: boolean = false;
  private autoSaveInterval: number | null = null;

  constructor() {
    this.saveData = this.loadFromStorage() || this.createDefaultSave();
    this.startAutoSave();
  }

  // Meta-progress (saves immediately)
  addSoulEchoes(amount: number): void {
    this.saveData.meta.soulEchoes += amount;
    this.saveData.meta.totalSoulEchoesEarned += amount;
    this.saveNow();
  }

  unlockAchievement(achievementId: string): void {
    if (!this.saveData.meta.unlockedAchievements.includes(achievementId)) {
      this.saveData.meta.unlockedAchievements.push(achievementId);
      this.saveNow();
    }
  }

  purchaseUpgrade(upgradeId: string): void {
    if (!this.saveData.meta.purchasedUpgrades.includes(upgradeId)) {
      this.saveData.meta.purchasedUpgrades.push(upgradeId);
      this.saveNow();
    }
  }

  // Run progress (marks dirty, batches saves)
  saveRunProgress(runData: Partial<RunSaveData>): void {
    if (this.saveData.run) {
      Object.assign(this.saveData.run, runData);
      this.markDirty();
    }
  }

  startNewRun(classId: CharacterClassId, seed: string): void {
    this.saveData.run = {
      seed,
      classId,
      currentAct: 1,
      currentNode: 'start',
      visitedNodes: [],
      map: generateMap(1, seed),
      player: createInitialPlayerState(classId),
      combat: null,
      runStatistics: createEmptyRunStats(),
      startTime: Date.now(),
    };
    this.saveNow();
  }

  endRun(victory: boolean): void {
    if (this.saveData.run) {
      // Update statistics
      const stats = this.saveData.meta.statistics;
      stats.totalRuns++;
      if (victory) stats.totalWins++;
      else stats.totalDeaths++;

      const classStats = stats.runsPerClass[this.saveData.run.classId];
      classStats.runs++;
      if (victory) classStats.wins++;

      // Clear run
      this.saveData.run = null;
      this.saveNow();
    }
  }

  abandonRun(): void {
    if (this.saveData.run) {
      this.saveData.meta.statistics.totalRuns++;
      this.saveData.run = null;
      this.saveNow();
    }
  }

  hasActiveRun(): boolean {
    return this.saveData.run !== null;
  }

  getRunSave(): RunSaveData | null {
    return this.saveData.run;
  }

  getMeta(): MetaSaveData {
    return this.saveData.meta;
  }

  // Persistence
  private saveNow(): void {
    this.backupCurrentSave();
    this.saveData.lastSaved = Date.now();
    this.saveData.checksum = this.calculateChecksum(this.saveData);
    const compressed = LZString.compressToUTF16(JSON.stringify(this.saveData));
    localStorage.setItem(STORAGE_KEY, compressed);
    this.isDirty = false;
  }

  private markDirty(): void {
    this.isDirty = true;
  }

  private startAutoSave(): void {
    // Save dirty data every 5 seconds
    this.autoSaveInterval = window.setInterval(() => {
      if (this.isDirty) {
        this.saveNow();
      }
    }, 5000);
  }

  private loadFromStorage(): SaveData | null {
    const compressed = localStorage.getItem(STORAGE_KEY);
    if (!compressed) return null;

    try {
      const json = LZString.decompressFromUTF16(compressed);
      const data = JSON.parse(json!) as SaveData;

      // Validate checksum
      const expectedChecksum = this.calculateChecksum(data);
      if (data.checksum !== expectedChecksum) {
        console.warn('Save checksum mismatch, attempting backup...');
        return this.loadBackup();
      }

      // Migrate if needed
      return this.migrate(data);
    } catch (e) {
      console.error('Failed to load save:', e);
      return this.loadBackup();
    }
  }

  private loadBackup(): SaveData | null {
    const backup = localStorage.getItem(BACKUP_KEY);
    if (!backup) return null;

    try {
      const json = LZString.decompressFromUTF16(backup);
      return JSON.parse(json!) as SaveData;
    } catch (e) {
      console.error('Backup also corrupted');
      return null;
    }
  }

  private backupCurrentSave(): void {
    const current = localStorage.getItem(STORAGE_KEY);
    if (current) {
      localStorage.setItem(BACKUP_KEY, current);
    }
  }

  private calculateChecksum(data: SaveData): string {
    // Simple hash of stringified data (excluding checksum field)
    const copy = { ...data, checksum: '' };
    const str = JSON.stringify(copy);
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash.toString(16);
  }

  private migrate(data: SaveData): SaveData {
    // Handle migrations from older versions
    if (data.version < SAVE_VERSION) {
      // Apply migrations in order
      for (let v = data.version; v < SAVE_VERSION; v++) {
        data = MIGRATIONS[v](data);
      }
      data.version = SAVE_VERSION;
    }
    return data;
  }

  private createDefaultSave(): SaveData {
    return {
      version: SAVE_VERSION,
      checksum: '',
      lastSaved: Date.now(),
      meta: {
        soulEchoes: 0,
        totalSoulEchoesEarned: 0,
        unlockedAchievements: [],
        achievementProgress: {},
        purchasedUpgrades: [],
        purchasedClasses: [],
        statistics: createEmptyStatistics(),
      },
      run: null,
      settings: DEFAULT_SETTINGS,
    };
  }
}

// Migration functions
const MIGRATIONS: Record<number, (data: SaveData) => SaveData> = {
  // Version 0 -> 1: Add statistics field
  0: (data) => {
    if (!data.meta.statistics) {
      data.meta.statistics = createEmptyStatistics();
    }
    return data;
  },
};
```

### Save Trigger Integration

```typescript
// In game flow controller
class GameController {
  private saveManager: SaveManager;

  onCombatEnd(result: CombatResult): void {
    // Update run stats
    this.saveManager.saveRunProgress({
      combat: null, // No longer in combat
    });

    // Statistics
    if (result.victory) {
      this.saveManager.updateStatistics({
        enemiesDefeated: result.enemiesDefeated,
        damageDealt: result.totalDamage,
        damageBlocked: result.totalBlock,
      });
    }
  }

  onCardSelected(card: Card): void {
    const deck = [...this.runState.deck, card];
    this.saveManager.saveRunProgress({
      player: { ...this.runState.player, deck },
    });
  }

  onMapNodeSelected(nodeId: string): void {
    this.saveManager.saveRunProgress({
      currentNode: nodeId,
      visitedNodes: [...this.runState.visitedNodes, nodeId],
    });
  }

  onMerchantPurchase(item: ShopItem): void {
    this.saveManager.saveRunProgress({
      player: {
        ...this.runState.player,
        gold: this.runState.player.gold - item.cost,
        // Add item to appropriate collection
      },
    });
  }
}
```

### Combat State Serialization

```typescript
// Saving mid-combat state
function serializeCombatState(engine: CombatEngine): CombatSaveData {
  const state = engine.getState();

  return {
    turn: state.turn,
    phase: state.phase,
    enemies: state.enemies.map(e => ({
      definitionId: e.id,
      currentHp: e.currentHp,
      block: e.block,
      statusEffects: e.statusEffects,
      intent: e.intent,
    })),
    hand: state.player.hand.map(c => c.instanceId),
    drawPile: state.player.drawPile.map(c => c.instanceId),
    discardPile: state.player.discardPile.map(c => c.instanceId),
    exhaustPile: state.player.exhaustPile.map(c => c.instanceId),
    playerBlock: state.player.block,
    playerResolve: state.player.resolve,
    playerStatusEffects: state.player.statusEffects,
  };
}

// Restoring combat from save
function deserializeCombatState(
  save: CombatSaveData,
  deck: Card[]
): CombatState {
  // Rebuild card instances from IDs
  const cardMap = new Map(deck.map(c => [c.instanceId, c]));

  return {
    turn: save.turn,
    phase: save.phase,
    enemies: save.enemies.map(e => restoreEnemy(e)),
    player: {
      hand: save.hand.map(id => cardMap.get(id)!),
      drawPile: save.drawPile.map(id => cardMap.get(id)!),
      discardPile: save.discardPile.map(id => cardMap.get(id)!),
      exhaustPile: save.exhaustPile.map(id => cardMap.get(id)!),
      block: save.playerBlock,
      resolve: save.playerResolve,
      statusEffects: save.playerStatusEffects,
    },
  };
}
```

### Abandon Run UI

```typescript
// In pause menu
function showAbandonConfirmation(): void {
  const dialog = createDialog({
    title: 'Abandon Run?',
    message: 'Your current run will be lost. This cannot be undone.',
    buttons: [
      {
        label: 'Abandon',
        style: 'danger',
        onClick: () => {
          saveManager.abandonRun();
          screenManager.navigateTo('main-menu');
        },
      },
      {
        label: 'Cancel',
        style: 'secondary',
        onClick: () => dialog.close(),
      },
    ],
  });
  dialog.show();
}
```

### Storage Size Estimation

```
Typical save sizes:
- Meta data: ~2 KB
- Run data (no combat): ~5 KB
- Run data (mid-combat): ~8 KB
- Settings: ~0.5 KB

With LZ-String compression: ~40% reduction
Total localStorage usage: ~10 KB compressed

localStorage limit: 5-10 MB (browser dependent)
Plenty of room for save data.
```

## Testing

### Test File Location
`src/tests/services/SaveManager.test.ts`

### Key Test Scenarios

1. **Round Trip**: Save and load produces identical data
2. **Checksum**: Tampered data detected
3. **Backup Recovery**: Corrupt save falls back to backup
4. **Migration**: Old version saves migrate correctly
5. **Run Lifecycle**: Start, save, load, end run
6. **Combat Save**: Mid-combat state serializes correctly
7. **Meta Persistence**: Achievements/upgrades save immediately
8. **Compression**: Large saves compress effectively

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-03 | 1.0 | Initial story creation | James (Dev) |

---

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

---

## QA Results
_To be filled by QA agent_
