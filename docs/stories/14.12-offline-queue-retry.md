# Story 14.12: Offline Queue & Retry

## Status: Draft

## Story

**As a** player with intermittent internet,
**I want** my progress to sync when I come back online,
**so that** I don't lose progress just because my connection dropped.

## Acceptance Criteria

1. Failed sync attempts are queued in localStorage
2. Queue is processed on next app load
3. Queue is processed when network comes back online
4. Only the latest save is synced (not every intermediate save)
5. Queue survives browser refresh/close
6. Successful sync clears the queue
7. UI indicates when syncs are pending

## Tasks

- [ ] Implement offline queue in localStorage
- [ ] Add queue processing on app load
- [ ] Add online/offline event listeners
- [ ] Implement queue deduplication (only keep latest)
- [ ] Add "Pending sync" indicator to UI
- [ ] Test offline → online flow
- [ ] Test browser close while offline → reopen online

## Technical Notes

### Offline Queue Structure

```typescript
// Stored in localStorage as 'sanctum_sync_queue'
interface OfflineQueue {
  pendingSave: SaveData | null;  // Only store latest save
  lastAttempt: number;           // Timestamp of last failed attempt
  attemptCount: number;          // For exponential backoff
}
```

### CloudSyncService Queue Implementation

```typescript
// src/services/CloudSyncService.ts

const QUEUE_STORAGE_KEY = 'sanctum_sync_queue';

class CloudSyncServiceClass {
  private isOnline: boolean = navigator.onLine;

  constructor() {
    // Listen for online/offline events
    window.addEventListener('online', () => this.handleOnline());
    window.addEventListener('offline', () => this.handleOffline());
  }

  private handleOnline(): void {
    console.log('Network restored, processing sync queue');
    this.isOnline = true;
    this.processQueue();
  }

  private handleOffline(): void {
    console.log('Network lost');
    this.isOnline = false;
  }

  // Called when a sync fails
  queueForRetry(data: SaveData): void {
    const queue: OfflineQueue = {
      pendingSave: data,
      lastAttempt: Date.now(),
      attemptCount: this.getQueue()?.attemptCount ?? 0 + 1
    };

    localStorage.setItem(QUEUE_STORAGE_KEY, JSON.stringify(queue));
    console.log('Sync queued for retry');
  }

  private getQueue(): OfflineQueue | null {
    const stored = localStorage.getItem(QUEUE_STORAGE_KEY);
    return stored ? JSON.parse(stored) : null;
  }

  private clearQueue(): void {
    localStorage.removeItem(QUEUE_STORAGE_KEY);
  }

  hasPendingSync(): boolean {
    return this.getQueue()?.pendingSave !== null;
  }

  // Called on app load and when coming back online
  async processQueue(): Promise<void> {
    if (!this.isOnline) {
      console.log('Still offline, skipping queue processing');
      return;
    }

    if (!AuthService.isAuthenticated()) {
      console.log('Not logged in, skipping queue processing');
      return;
    }

    const queue = this.getQueue();
    if (!queue?.pendingSave) {
      console.log('No pending syncs in queue');
      return;
    }

    // Exponential backoff
    const backoffMs = Math.min(1000 * Math.pow(2, queue.attemptCount), 60000);
    const timeSinceLastAttempt = Date.now() - queue.lastAttempt;

    if (timeSinceLastAttempt < backoffMs) {
      console.log(`Backoff: waiting ${backoffMs - timeSinceLastAttempt}ms before retry`);
      setTimeout(() => this.processQueue(), backoffMs - timeSinceLastAttempt);
      return;
    }

    try {
      console.log('Processing queued sync...');
      await this.pushToCloud(queue.pendingSave);
      console.log('Queued sync succeeded!');
      this.clearQueue();
      SaveManager.setSyncStatus('synced');
    } catch (error) {
      console.error('Queued sync failed:', error);
      // Update attempt count and try again later
      this.queueForRetry(queue.pendingSave);
    }
  }

  async pushToCloud(data: SaveData): Promise<void> {
    if (!this.isOnline) {
      throw new Error('Offline');
    }

    const response = await fetch(`${API_URL}/api/sync/push`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...AuthService.getAuthHeaders()
      },
      body: JSON.stringify({
        data: compressSaveData(data),
        timestamp: data.lastSaved
      })
    });

    if (!response.ok) {
      throw new Error(`Sync failed: ${response.status}`);
    }
  }
}

export const CloudSyncService = new CloudSyncServiceClass();
```

### App Load Integration

```typescript
// src/main.ts

async function initializeApp(): Promise<void> {
  // ... existing initialization ...

  if (AuthService.isAuthenticated()) {
    // Process any pending syncs first
    await CloudSyncService.processQueue();

    // Then do normal sync on load
    await syncOnLoad();
  }
}
```

### UI Indicator for Pending Sync

```typescript
// src/ui/components/SyncIndicator.ts

function renderSyncIndicator(status: SyncStatus): string {
  // Add 'pending' state for queued syncs
  if (CloudSyncService.hasPendingSync() && status !== 'syncing') {
    return `
      <div class="sync-indicator sync-indicator--pending">
        <span class="sync-pending-icon">↻</span>
        <span class="sync-label">Sync pending</span>
      </div>
    `;
  }

  // ... existing status rendering ...
}
```

### CSS for Pending State

```css
.sync-indicator--pending {
  color: var(--color-warning);
}

.sync-pending-icon {
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}
```

### Queue Deduplication

Only the latest save matters:

```typescript
// When queueing, always replace the pending save
queueForRetry(data: SaveData): void {
  const existingQueue = this.getQueue();

  // If new save is older than queued save, ignore it
  if (existingQueue?.pendingSave &&
      existingQueue.pendingSave.lastSaved > data.lastSaved) {
    return; // Keep the newer queued save
  }

  // Replace with newer save
  const queue: OfflineQueue = {
    pendingSave: data,
    lastAttempt: Date.now(),
    attemptCount: existingQueue?.attemptCount ?? 0
  };

  localStorage.setItem(QUEUE_STORAGE_KEY, JSON.stringify(queue));
}
```

### Backoff Strategy

```
Attempt 1: Immediate
Attempt 2: Wait 2 seconds
Attempt 3: Wait 4 seconds
Attempt 4: Wait 8 seconds
Attempt 5: Wait 16 seconds
Attempt 6: Wait 32 seconds
Attempt 7+: Wait 60 seconds (max)
```

## Definition of Done

- [ ] Failed syncs are queued in localStorage
- [ ] Queue survives browser refresh
- [ ] Queue processes on app load
- [ ] Queue processes when network restored
- [ ] Only latest save is synced (not duplicates)
- [ ] UI shows pending sync indicator
- [ ] Successful sync clears queue

## Dependencies

- Story 14.9 (SaveManager Refactor)
- Story 14.10 (Cloud Sync on App Load)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-05 | 1.0 | Story created | Mary (Analyst) |
