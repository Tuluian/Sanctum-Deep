# Story 14.3: Save Data Schema

## Status: Draft

## Story

**As a** developer,
**I want** to create the database schema for player save data,
**so that** player progress can be stored and synced across devices.

## Acceptance Criteria

1. Save data table stores compressed JSON blob per user
2. Timestamp tracks when save was last updated
3. Schema supports the full SaveData interface from SaveManager.ts
4. Purchases table tracks DLC ownership separately (for quick lookups)
5. Data is stored efficiently (compressed)
6. Single save slot per user (no multiple save slots)

## Tasks

- [ ] Create migration file for save_data table
- [ ] Create migration file for purchases table
- [ ] Implement compression/decompression utilities
- [ ] Test storage of full SaveData object
- [ ] Verify data integrity after round-trip (save â†’ load)
- [ ] Document data format and versioning strategy

## Technical Notes

### Schema Definition

```sql
-- Migration: 004_create_save_data.sql

CREATE TABLE save_data (
  user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
  data TEXT NOT NULL,  -- Compressed JSON (LZ-String base64)
  data_version INTEGER NOT NULL DEFAULT 1,  -- For future migrations
  last_saved BIGINT NOT NULL,  -- JS timestamp from client
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Migration: 005_create_purchases.sql

CREATE TABLE purchases (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  product_id VARCHAR(100) NOT NULL,  -- e.g., 'class_diabolist'
  platform VARCHAR(50) NOT NULL,  -- 'stripe', 'apple', 'google'
  receipt_id VARCHAR(255),  -- Platform-specific receipt/transaction ID
  purchased_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, product_id)
);

CREATE INDEX idx_purchases_user ON purchases(user_id);
```

### Data Format

The `data` column stores a compressed representation of the `SaveData` interface:

```typescript
// From SaveManager.ts
interface SaveData {
  version: number;
  lastSaved: number;
  meta: MetaSaveData;
  run: RunSaveData | null;
  settings: GameSettings;  // Note: Settings stored but NOT synced to cloud
}

interface MetaSaveData {
  soulEchoes: number;
  unlockedAchievements: string[];
  purchasedUpgrades: string[];
  purchasedClasses: CharacterClassId[];
  statistics: PlayerStatistics;
}
```

### Compression Strategy

```typescript
import LZString from 'lz-string';

export function compressSaveData(data: SaveData): string {
  // Remove settings before cloud storage (device-specific)
  const cloudData = {
    ...data,
    settings: undefined
  };
  return LZString.compressToBase64(JSON.stringify(cloudData));
}

export function decompressSaveData(compressed: string): Omit<SaveData, 'settings'> {
  const json = LZString.decompressFromBase64(compressed);
  if (!json) throw new Error('Failed to decompress save data');
  return JSON.parse(json);
}
```

### Why Separate Purchases Table?

1. **Quick ownership checks** - Don't need to decompress save data
2. **Receipt verification** - Store platform-specific receipts
3. **Cross-platform purchases** - Track where purchase originated
4. **Never lose purchases** - Even if save data gets corrupted

### Data Versioning

The `data_version` column tracks the schema version of the compressed data:

```typescript
const CURRENT_DATA_VERSION = 1;

// When loading, check version and migrate if needed
function migrateData(data: unknown, fromVersion: number): SaveData {
  let migrated = data;

  if (fromVersion < 1) {
    // Future: migrate from v0 to v1
  }

  return migrated as SaveData;
}
```

## Definition of Done

- [ ] Migrations run successfully
- [ ] Can save and load full SaveData object
- [ ] Compression reduces data size by >50%
- [ ] Purchases table correctly tracks ownership
- [ ] Data survives round-trip without corruption

## Dependencies

- Story 14.1 (Heroku Postgres Setup)
- Story 14.2 (Users & Auth Schema)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-05 | 1.0 | Story created | Mary (Analyst) |
